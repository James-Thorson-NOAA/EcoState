[{"path":"/articles/eastern_bering_sea.html","id":"eastern-bering-sea","dir":"Articles","previous_headings":"","what":"Eastern Bering Sea","title":"Eastern Bering Sea case study","text":"first load Survey, Catch, PB, QB values, define biological inputs: fit function call. slow: can plot estimated foodweb:","code":"# load data data(eastern_bering_sea)  # Reformat inputs years = 1982:2021 # Catch only goes through 2021, and starting pre-data in 1982 doesn't play well with fit_B0 taxa = c( \"Pollock\", \"Cod\", \"Arrowtooth\", \"Copepod\", \"Other_zoop\", \"Chloro\", \"NFS\", \"Krill\", \"Benthic_invert\", \"Benthos\", \"Detritus\" )  # Define types type_i = sapply( taxa, FUN=switch, \"Detritus\" = \"detritus\",                                    \"Chloro\" = \"auto\",                                    \"hetero\" )  # Starting values U_i = EE_i = B_i = array( NA, dim=length(taxa),                      dimnames=list(names(eastern_bering_sea$P_over_B))) B_i[c(\"Cod\", \"Arrowtooth\", \"NFS\")] = c(1, 0.5, 0.02) EE_i[] = 1 U_i[] = 0.2  # Define default vulnerability, except for primary producers X_ij = array( 2, dim=c(length(taxa),length(taxa)) ) dimnames(X_ij) = list(names(B_i),names(B_i)) X_ij[,'Chloro'] = 91 # Define parameters to estimate fit_Q = c(\"Pollock\", \"Copepod\", \"Chloro\", \"Other_zoop\", \"Krill\") fit_B0 = c(\"Pollock\", \"Cod\", \"Arrowtooth\", \"NFS\") fit_B = c(\"Cod\", \"Arrowtooth\", \"NFS\")    # Define process errors to estimate # Only estimating Pollock to speed up demonstration fit_eps = \"Pollock\"  # Which taxa to include taxa_to_include = c( \"NFS\", \"Pollock\", \"Copepod\", \"Chloro\", \"Krill\" ) # To run full model use: # taxa_to_include = taxa  # Run model out = ecostate( taxa = taxa_to_include,                 years = years,                 catch = eastern_bering_sea$Catch,                 biomass = eastern_bering_sea$Survey,                 PB = eastern_bering_sea$P_over_B,                 QB = eastern_bering_sea$Q_over_B,                 DC = eastern_bering_sea$Diet_proportions,                 B = B_i,                 EE = EE_i,                 U = U_i,                 type = type_i,                 X = X_ij,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 control = ecostate_control( n_steps = 20, # using 15 by default                                             start_tau = 0.01,                                             tmbad.sparse_hessian_compress = 0 ))  # print output out #> Dynamics integrated using  ABM  with  20  time-steps #> Run time: Time difference of 3.688347 mins #> Negative log-likelihood: 110.8242 #>  #> EcoSim parameters: #>           type        QB          PB          B EE   U #> NFS     hetero 57.763550  0.09429851 0.01610613  0 0.2 #> Pollock hetero  4.225892  0.82452074 3.26791790  1 0.2 #> Copepod hetero 27.740000  6.00000000 1.85304306  1 0.2 #> Chloro    auto        NA 99.40685006 0.63415347  1 0.2 #> Krill   hetero 15.640000  5.48000000 1.05396595  1 0.2 #>  #> EcoSim diet matrix: #>          Predator #> Prey      NFS   Pollock Copepod Chloro     Krill #>   NFS       0 0.0000000       0      0 0.0000000 #>   Pollock   1 0.1277434       0      0 0.0000000 #>   Copepod   0 0.4540243       0      0 0.2941176 #>   Chloro    0 0.0000000       1      0 0.7058824 #>   Krill     0 0.4182324       0      0 0.0000000 #>  #> EcoSim vulnerability matrix: #>         NFS Pollock Copepod Chloro Krill #> NFS       2       2       2     91     2 #> Pollock   2       2       2     91     2 #> Copepod   2       2       2     91     2 #> Chloro    2       2       2     91     2 #> Krill     2       2       2     91     2 #>  #> Estimates: sdreport(.) result #>            Estimate Std. Error #> delta_i  -0.9112170 0.07451987 #> delta_i  -0.9721216 0.10271052 #> logB_i   -4.1285552 0.05717952 #> logtau_i -1.1372673 0.14316381 #> logq_i    0.9286230 0.05601754 #> logq_i    0.9999230 0.06783386 #> logq_i    2.6846407 0.05952428 #> logq_i    2.3981400 0.07601978 #> Maximum gradient component: 9.811169e-05 # Plot foodweb at equilibrium # using pelagic producers as x-axis and trophic level as y-axis plot_foodweb( out$rep$out_initial$Qe_ij,                 xtracer_i = ifelse(taxa_to_include==\"Krill\",1,0),               B_i = out$rep$out_initial$B_i,               type_i = type_i[taxa_to_include] ) #> Warning: Removed 4 rows containing missing values or values outside the scale range #> (`geom_point()`)."},{"path":"/articles/simulation.html","id":"simulation-demonstration","dir":"Articles","previous_headings":"","what":"Simulation demonstration","title":"Demonstrating EcoState via simulation","text":"first simulate new data. , specify 5-species ecosystem: first define function simulates data, using functions mass-balance simulating dynamics used EcoState parameter estimation:","code":"# Time-interval years = 1981:2020 n_years = length(years)  # Name taxa (optional, for illustration) taxa = c(\"Consumer_1\", \"Consumer_2\", \"Predator_1\", \"Predator_2\", \"Producer\", \"Detritus\") n_species = length(taxa)  # Ecopath-with-EcoSim parameters # Diet matrix DC_ij = matrix( c(   0,     0,     0.8,  0.4,  0,   0,   0,     0,     0.2,  0.6,  0,   0,   0,     0,     0,    0,    0,   0,   0,     0,     0,    0,    0,   0,   0.9,   0.3,   0,    0,    0,   0,   0.1,   0.7,   0,    0,    0,   0 ), byrow=TRUE, ncol=n_species) PB_i = c( 4, 1, 0.2, 0.1, 90, 0.5 )         # Reciprocal of mean age according to Polovina-1984 ~= M QB_i = c( 10, 4, 3, 1, NA, NA ) EE_i = c( 0.9, 0.9, NA, NA, 0.9, 0.9 ) B_i = c( NA, NA, 1, 1, NA, NA ) U_i = rep( 0.2, n_species ) type_i = c( \"hetero\", \"hetero\", \"hetero\", \"hetero\", \"auto\", \"detritus\" ) which_primary = which(type_i==\"auto\") which_detritus = which(type_i==\"detritus\") X_ij = matrix( 2, nrow=n_species, ncol=n_species ) X_ij[,which_primary] = 91 simulate_data = function(){   # Simulate process errors   set.seed(101)   rarray = \\(x,dims=dim(x),sd) array( sd*rnorm(prod(dims)), dim=dims )   epsilon_ti = rarray(dims=c(n_years,n_species),sd=1) * outer(rep(1,n_years),sigmaB_i)      # Choose method to integrate instantaneous rates for annual dynamics   n_steps = 10   project_vars = abm3pc_sys      # Define parameters   Pars = list( logB_i = log( B_i ),                       logPB_i = log(PB_i),                      logQB_i = log(QB_i),                      Xprime_ij = log(X_ij - 1),                      EE_i = EE_i,                      DC_ij = DC_ij,                      U_i = U_i,                      type_i = type_i,                      noB_i = ifelse( is.na(B_i), 1, 0),                      epsilon_i = rep(0,n_species),                      logF_i = rep(-Inf,n_species),                      which_primary = which_primary,                      which_detritus = which_detritus,                      F_type = \"integrated\" )   Pars_full = add_equilibrium( Pars,                                scale_solver = \"joint\",                                noB_i = ifelse(is.na(Pars$logB_i),1,0),                                type_i = type_i )    # Project forward   Bobs_ti = Cobs_ti = B_ti = C_ti = array( NA, dim=c(n_years,n_species),                                      dimnames=list(\"Year\"=years,\"Taxon\"=taxa) )   B_ti[1,] = exp(Pars_full$logB_i)   C_ti[1,] = NA      for( t in seq_along(years)[-1] ){     # Fishing mortality ramps up for two predators     F_t = c( 0, 0, t/n_years*0.2, t/n_years*0.1, 0, 0 )        #     pars_t = Pars_full     pars_t$logF_i = log(F_t)     pars_t$epsilon_i = epsilon_ti[t,]          # Integrate dynamics annually     data2 = local({                     n_species = n_species                     environment()     })     environment(dBdt) <- data2     sim = project_vars(           f = dBdt,           a = years[t-1],            b = years[t],           n = n_steps,           Pars = pars_t,           y0 = c( B_ti[t-1,], rep(0,n_species) ) )          # Record results     B_ti[t,] = sim$y[nrow(sim$y),seq_len(n_species)]     C_ti[t,] = sim$y[nrow(sim$y),n_species+seq_len(n_species)]        # Simulate measurement errors     Bobs_ti[t,] = B_ti[t,] * exp(0.1*rnorm(n_species))     Cobs_ti[t,] = ifelse(C_ti[t,]==0,NA,C_ti[t,]) * exp(0.1*rnorm(n_species))   }   return( list( \"B_ti\"=B_ti, \"C_ti\"=C_ti, \"Bobs_ti\"=Bobs_ti,                  \"Cobs_ti\"=Cobs_ti, \"Pars_full\"=Pars_full) ) }"},{"path":"/articles/simulation.html","id":"comparison-with-rpath","dir":"Articles","previous_headings":"","what":"Comparison with Rpath","title":"Demonstrating EcoState via simulation","text":"first compare functions used EcoState existing implementations model. One script-based implementation available R Rpath, therefore show syntax model-output comparison. comparison, first simulate data set process errors: load Rpath reformat inputs format expects calculate mass-balance: can simulate forward time using Rpath: Comparing scenario forecasted Rpath simulated time-series, see two closely match. EcoState uses functions fitting, also closely matches Rpath.","code":"sigmaB_i = c(0, 0, 0, 0, 0, 0) # Taxa 1-2 crashes solver if sigmaB > 0.02 sim = simulate_data() library(Rpath)  # Rpath needs types in ascending order (EcoState doesn't care) types  <- sapply( c(type_i,\"fishery\"), FUN=switch,                    \"hetero\"==0, \"auto\"=1, \"detritus\"=2, \"fishery\"=3 ) groups <- c( taxa, \"fishery\" ) stgroups = rep(NA, length(groups) ) REco.params <- create.rpath.params(group = groups, type = types, stgroup = stgroups)  # Fill in biomass #REco.params$model$Biomass = c( exp(Pars_full$logB_i), NA ) REco.params$model$Biomass = c( B_i, NA ) REco.params$model$EE = c( ifelse(type_i==\"detritus\",NA,EE_i), NA ) REco.params$model$PB = c( PB_i, NA ) REco.params$model$QB = c( QB_i, NA )  #Biomass accumulation and unassimilated consumption REco.params$model$BioAcc = c( rep(0,length(taxa)), NA ) REco.params$model$Unassim = c( ifelse(type_i==\"hetero\",0.2,0), NA )  #Detrital Fate REco.params$model$Detritus = c( ifelse(type_i==\"detritus\",0,1), 0 ) REco.params$model$fishery = c( rep(0,length(taxa)), NA ) REco.params$model$fishery.disc = c( rep(0,length(taxa)), NA )  # Diet for(j in 1:5) REco.params$diet[seq_along(taxa),j+1] = DC_ij[,j] REco.params$diet[seq_along(taxa),2] = DC_ij[,1]  # Balance using Ecopath equations check.rpath.params( REco.params) #> Rpath parameter file is functional. REco <- rpath(REco.params, eco.name = 'R Ecosystem') # Create simulation object REco.sim <- rsim.scenario(REco, REco.params, years = 1:40)  # REco.sim = adjust.fishing( Rsim.scenario=REco.sim,                             parameter='ForcedFRate',                             group = 'Predator_1', # Group is which species to apply                            sim.year = 1:40,                             sim.month = 0,                             value = (1:40/40)*0.2 ) REco.sim = adjust.fishing( Rsim.scenario=REco.sim,                             parameter='ForcedFRate',                             group = 'Predator_2', # Group is which species to apply                            sim.year = 1:40,                             sim.month = 0,                             value = (1:40/40)*0.1 )  # Match vulnerability for self-limitation in Producers REco.sim$params$VV[which(REco.sim$params$PreyFrom==0 & REco.sim$params$PreyTo==5)] = 91  #  REco.run1 <- rsim.run(REco.sim, method = 'RK4', years = 1:40) # Calculate annual simulated catch Year = rep( years, each=12) Bsim_ti = apply( REco.run1$out_Biomass[,-1], MARGIN=2, FUN=\\(x) tapply(x,INDEX=Year,FUN=mean) )  # par(mfrow=c(2,1), mar=c(3,3,1,1), mgp=c(2,0.5,0) ) matplot( x=years, y=Bsim_ti / outer(rep(1,n_years),Bsim_ti[1,]),           type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (Rpath)\", xlab=\"Year\" ) Brel_ti = sim$B_ti / outer(rep(1,n_years),sim$B_ti[1,]) matplot( x=years, y=sim$B_ti / outer(rep(1,n_years),sim$B_ti[1,]),           type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (Simulated)\", xlab=\"Year\" ) legend(\"bottomleft\", fill=rainbow(n_species), legend=taxa, ncol=2, bty=\"n\")"},{"path":"/articles/simulation.html","id":"fitting-the-model-using-ecostate","dir":"Articles","previous_headings":"","what":"Fitting the model using EcoState","title":"Demonstrating EcoState via simulation","text":"next want show EcoState performs fitting simulated data. simulate data set process errors, plot compare previous simulation process errors:  reformat simulated biomass catch time-series long-form data frames fit ecostate Finally, can extract elements fitted model, plot easily using ggplot2 compare known (simulated) values. exercise shows EcoState can accurately estimate biomass trends:","code":"# Simulate new data sigmaB_i = c(0.02, 0.02, 0.1, 0.1, 0.1, 0.1) # Taxa 1-2 crashes solver if sigmaB > 0.02 sim = simulate_data()  # Unload simulated data Bobs_ti = sim$Bobs_ti Cobs_ti = sim$Cobs_ti B_ti = sim$B_ti Pars_full = sim$Pars_full  # Plot simulation with process errors matplot( x=years, y=B_ti / outer(rep(1,n_years),B_ti[1,]),           type=\"l\", lwd=3, lty=\"solid\", col=rainbow(n_species), log=\"y\",          ylab=\"Relative biomass (simulated)\", xlab=\"Year\" ) # reformat to longform data-frame Catch = na.omit(data.frame(expand.grid(dimnames(Cobs_ti)), \"Mass\"=as.vector(Cobs_ti))) Biomass = na.omit(data.frame(expand.grid(dimnames(Bobs_ti)), \"Mass\"=as.vector(Bobs_ti)))  # Settings: specify what parameters to estimate fit_eps = c(\"Producer\", \"Detritus\", \"Predator_1\", \"Predator_2\")   # process errors fit_Q = c()       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = taxa       # equilibrium biomass  # Solving for EE and giving uninformed initial values for biomass fittedB_i = exp(Pars_full$logB_i) fittedEE_i = rep(NA, n_species)  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(fittedB_i) = names(fittedEE_i) = names(type_i) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 control = ecostate_control( inverse_method = \"Standard\",                                              trace = 1,                                             nlminb_loops = 1,                                             tmbad.sparse_hessian_compress = 0,  # Much faster to turn off                                             getsd = TRUE,                                             process_error = \"epsilon\",  # alpha is faster than epsilon                                             profile = c(\"logF_ti\",\"logB_i\"),                                             start_tau = 0.001 ))    #>   0:    -175.67951: -6.90776 -6.90776 -6.90776 -6.90776 #>   1:    -176.09205: -6.45547 -6.65726 -6.90774 -6.87630 #>   2:    -194.07887: -4.51446 -5.93490 -6.90771 -6.81779 #>   3:    -231.52565: -2.28383 -5.79723 -6.90771 -6.81528 #>   4:    -246.17855: -2.53994 -3.58688 -6.90762 -6.60686 #>   5:    -254.85582: -2.53612 -2.37286 -6.90751 -6.60556 #>   6:    -255.08065: -2.44978 -2.45820 -6.90751 -6.60496 #>   7:    -255.08182: -2.45253 -2.57374 -6.90753 -6.56779 #>   8:    -255.10439: -2.43108 -2.51739 -6.90752 -6.57478 #>   9:    -255.10608: -2.44549 -2.51686 -6.90752 -6.57398 #>  10:    -255.10628: -2.44407 -2.51297 -6.90753 -6.56015 #>  11:    -255.10681: -2.44004 -2.51405 -6.90754 -6.52541 #>  12:    -255.10898: -2.43522 -2.51301 -6.90758 -6.38555 #>  13:    -255.97851: -2.37578 -2.49770 -6.90821 -4.14722 #>  14:    -258.84048: -2.39224 -2.49867 -6.90845 -3.25170 #>  15:    -262.20225: -2.43521 -2.51084 -6.90862 -2.45701 #>  16:    -262.56510: -2.41559 -2.57204 -6.90862 -2.24141 #>  17:    -262.57940: -2.43126 -2.58874 -6.90862 -2.21391 #>  18:    -262.58100: -2.41829 -2.60958 -6.90862 -2.18788 #>  19:    -262.58231: -2.42628 -2.60835 -6.90862 -2.19131 #>  20:    -262.58237: -2.42845 -2.60079 -6.90863 -2.19523 #>  21:    -262.58248: -2.42698 -2.60414 -6.90863 -2.19646 #>  22:    -262.58249: -2.42756 -2.60460 -6.90863 -2.19634 #>  23:    -262.58249: -2.42748 -2.60529 -6.90863 -2.19606 #>  24:    -262.58249: -2.42753 -2.60524 -6.90863 -2.19605 #>  25:    -262.58249: -2.42753 -2.60520 -6.90863 -2.19606 #>  26:    -262.58249: -2.42753 -2.60517 -6.90863 -2.19606 #>  27:    -262.58249: -2.42753 -2.60517 -6.90863 -2.19606  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 4.289819 mins #> Negative log-likelihood: -262.5825 #>  #> EcoSim parameters: #>                type QB   PB         B        EE   U #> Consumer_1   hetero 10  4.0 0.7859555 0.8561942 0.2 #> Consumer_2   hetero  4  1.0 1.3010913 0.8725432 0.2 #> Predator_1   hetero  3  0.2 0.9674416 0.0000000 0.2 #> Predator_2   hetero  1  0.1 0.9246556 0.0000000 0.2 #> Producer       auto NA 90.0 0.1008427 0.9514173 0.2 #> Detritus   detritus NA  0.5 9.5704738 0.9255574 0.2 #>  #> EcoSim diet matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1        0.0        0.0        0.8        0.4        0        0 #>   Consumer_2        0.0        0.0        0.2        0.6        0        0 #>   Predator_1        0.0        0.0        0.0        0.0        0        0 #>   Predator_2        0.0        0.0        0.0        0.0        0        0 #>   Producer          0.9        0.3        0.0        0.0        0        0 #>   Detritus          0.1        0.7        0.0        0.0        0        0 #>  #> EcoSim vulnerability matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1          2          2          2          2       91        2 #>   Consumer_2          2          2          2          2       91        2 #>   Predator_1          2          2          2          2       91        2 #>   Predator_2          2          2          2          2       91        2 #>   Producer            2          2          2          2       91        2 #>   Detritus            2          2          2          2       91        2 #>  #> Estimates: sdreport(.) result #>           Estimate  Std. Error #> logtau_i -2.427535   0.2049494 #> logtau_i -2.605169   0.3047519 #> logtau_i -6.908635 624.7193216 #> logtau_i -2.196062   0.2882175 #> Maximum gradient component: 0.0001702973 # Extract estimated biomass Bhat_ti = as.list(out$sdrep, what=\"Estimate\", report=TRUE )$B_ti Bse_ti = as.list(out$sdrep, what=\"Std. Error\", report=TRUE )$B_ti  # Reformat to long-form data frame for ggplot results = expand.grid(dimnames(Bobs_ti)) results = cbind( results,                   \"True\" = as.vector(B_ti),                  \"Est\" = as.vector(Bhat_ti),                  \"SE\" = as.vector(Bse_ti) )  # Plot using ggplot library(ggplot2) ggplot(results) +    geom_line( aes(x=as.numeric(Year), y=True) ) +    facet_wrap( vars(Taxon), scale=\"free\" ) +   geom_line( aes(x=as.numeric(Year), y=Est), linetype=\"dotted\" ) +   geom_ribbon( aes(x=as.numeric(Year), ymin=Est-SE, ymax=Est+SE), alpha=0.2)"},{"path":"/articles/simulation.html","id":"advanced-estimating-vulnerability-parameters","dir":"Articles","previous_headings":"","what":"Advanced: estimating vulnerability parameters","title":"Demonstrating EcoState via simulation","text":"can also explore estimating additional parameters. , explore estimating vulnerability:","code":"# Run model out0 = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 control = ecostate_control( inverse_method = \"Standard\",                                              nlminb_loops = 0,                                             tmbad.sparse_hessian_compress = 0,                                               getsd = FALSE,                                             process_error = \"epsilon\",                                             profile = c(\"logF_ti\",\"logB_i\"),                                             start_tau = 0.001 ))   # alpha is faster than epsilon  # Change tmb_par tmb_par = out0$tmb_inputs$p   tmb_par$Xprime_ij[,which(type_i!=\"auto\")] = log(1.5 - 1)  map = out0$tmb_inputs$map   map$Xprime_ij = array(NA, dim=dim(tmb_par$Xprime_ij))   map$Xprime_ij[,which(type_i!=\"auto\")] = 1   map$Xprime_ij = factor(map$Xprime_ij)  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = fittedB_i,                 EE = fittedEE_i,                 X = X_ij,                 type = type_i,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_eps,                 fit_B0 = fit_B0,                 control = ecostate_control( inverse_method = \"Standard\",                                              nlminb_loops = 1,                                             tmbad.sparse_hessian_compress = 0,                                               getsd = TRUE,                                             process_error = \"epsilon\",                                             profile = c(\"logF_ti\",\"logB_i\"),                                             start_tau = 0.001,                                             tmb_par = tmb_par,                                             map = map ))   # alpha is faster than epsilon #> Using `control$tmb_par`, so be cautious in constructing it #> Using `control$map`, so be cautious in constructing it #> Warning in nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr, : #> NA/NaN function evaluation #> Warning in nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr, : #> NA/NaN function evaluation #> Warning in nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr, : #> NA/NaN function evaluation #> Warning in nlminb(start = opt$par, objective = obj$fn, gradient = obj$gr, : #> NA/NaN function evaluation  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 13.46761 mins #> Negative log-likelihood: -262.5825 #>  #> EcoSim parameters: #>                type QB   PB         B        EE   U #> Consumer_1   hetero 10  4.0 0.7859487 0.8562777 0.2 #> Consumer_2   hetero  4  1.0 1.3011220 0.8726118 0.2 #> Predator_1   hetero  3  0.2 0.9675226 0.0000000 0.2 #> Predator_2   hetero  1  0.1 0.9247681 0.0000000 0.2 #> Producer       auto NA 90.0 0.1008435 0.9514061 0.2 #> Detritus   detritus NA  0.5 9.5704580 0.9255754 0.2 #>  #> EcoSim diet matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1        0.0        0.0        0.8        0.4        0        0 #>   Consumer_2        0.0        0.0        0.2        0.6        0        0 #>   Predator_1        0.0        0.0        0.0        0.0        0        0 #>   Predator_2        0.0        0.0        0.0        0.0        0        0 #>   Producer          0.9        0.3        0.0        0.0        0        0 #>   Detritus          0.1        0.7        0.0        0.0        0        0 #>  #> EcoSim vulnerability matrix: #>             Predator #> Prey         Consumer_1 Consumer_2 Predator_1 Predator_2 Producer Detritus #>   Consumer_1   1.999266   1.999266   1.999266   1.999266       91 1.999266 #>   Consumer_2   1.999266   1.999266   1.999266   1.999266       91 1.999266 #>   Predator_1   1.999266   1.999266   1.999266   1.999266       91 1.999266 #>   Predator_2   1.999266   1.999266   1.999266   1.999266       91 1.999266 #>   Producer     1.999266   1.999266   1.999266   1.999266       91 1.999266 #>   Detritus     1.999266   1.999266   1.999266   1.999266       91 1.999266 #>  #> Estimates: sdreport(.) result #>                Estimate  Std. Error #> Xprime_ij -0.0007346168   0.1769047 #> logtau_i  -2.4276318459   0.2064240 #> logtau_i  -2.6048038918   0.3155934 #> logtau_i  -6.9077525593 613.9938951 #> logtau_i  -2.1959829825   0.2887926 #> Maximum gradient component: 0.0001617564"},{"path":"/articles/surplus_production.html","id":"simulation-demonstration","dir":"Articles","previous_headings":"","what":"Simulation demonstration","title":"EcoState as surplus production model","text":"first simulate new data. , simulate Schaefer production model Gompertz effort dynamics:  set inputs EcoState Next, fit ecostate Finally can calculate function calculates annualized surplus production use function compare exact approximation uses first-order Euler approximation:  can also plot estimated true biomass","code":"# Time-interval years = 1981:2020 n_years = length(years)  # Biology r = 0.2 #MSY = 100 K = 1000 sigmaB = 0.5 B0 = K * exp(sigmaB*rnorm(1)) prod_func = c(\"Schaefer\", \"Fox\")[2]  # Effort dynamics Bequil = 0.4 * K Brate = 0.2 sigmaE = 0.1 E0 = 0.01  # Survey q = 1 sigmaQ = 0.1  # Pbar_t = P_t = C_t = E_t = B_t = rep(NA, n_years) B_t[1] = B0 E_t[1] = E0  # for( t in 2:n_years ){   if(prod_func==\"Scaefer\") Pbar_t[t] = B_t[t-1] + r * B_t[t-1] * (1 - B_t[t-1]/K)   if(prod_func==\"Fox\") Pbar_t[t] = r * B_t[t-1] * log(K / B_t[t-1])   P_t[t] = Pbar_t[t] * exp(sigmaB*rnorm(1))   B_t[t] = B_t[t-1] + P_t[t]   E_t[t] = E_t[t-1] * (B_t[t-1]/Bequil)^Brate * exp(sigmaE*rnorm(1))   C_t[t] = B_t[t] * (1 - exp(-E_t[t]))   B_t[t] = B_t[t] - C_t[t] } Bobs_t = q * B_t * exp(sigmaQ * rnorm(n_years))  #  matplot( x=years, y=cbind(B_t,Bobs_t,C_t), type=\"l\", log=\"y\", lty=\"solid\") # Name taxa (optional, for illustration) taxa = \"target\" n_taxa = length(taxa)  # Ecopath-with-EcoSim parameters # Diet matrix DC_ij = array( 0, dim=c(1,1) ) PB_i = 0.1 QB_i = NA EE_i = 1 B_i = 1 U_i = 0.2 type_i = \"auto\" X_ij = array( 2, dim=c(1,1) )  # reformat to longform data-frame Catch = na.omit(data.frame( \"Mass\" = C_t, \"Year\" = years, \"Taxon\" = taxa )) Biomass = data.frame( \"Mass\" = Bobs_t, \"Year\" = years, \"Taxon\" = taxa ) # Settings: specify what parameters to estimate fit_delta = taxa   # process errors fit_Q = taxa       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = taxa       # equilibrium biomass  # Treat it as an autotroph (given there's no prey to consume) type = \"auto\"  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Run model out0 = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_delta,                 fit_B0 = fit_B0,                 control = ecostate_control( nlminb_loops = 0,                                             getsd = FALSE ) )  # Estimate logPB pars = out0$tmb_inputs$p map = out0$tmb_inputs$map map$Xprime_ij = factor(1)  # Run model out = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_delta,                 fit_B0 = fit_B0,                 control = ecostate_control( map = map,                                             tmb_par = pars ) ) #> Using `control$tmb_par`, so be cautious in constructing it #> Using `control$map`, so be cautious in constructing it  # print output to terminal out #> Dynamics integrated using  ABM  with  10  time-steps #> Run time: Time difference of 5.068917 secs #> Negative log-likelihood: -80.04545 #>  #> EcoSim parameters: #>        type QB  PB        B EE   U #> target auto NA 0.1 1340.769  0 0.2 #>  #> EcoSim diet matrix: #>         Predator #> Prey     target #>   target      0 #>  #> EcoSim vulnerability matrix: #>         Predator #> Prey       target #>   target 1.059258 #>  #> Estimates: sdreport(.) result #>              Estimate   Std. Error #> logB_i      7.2009983 8.730774e-02 #> Xprime_ij  -2.8258572 9.229292e-01 #> logtau_i  -13.4706023 5.068437e+03 #> logq_i     -0.3438141 1.086117e-01 #> Maximum gradient component: 0.0004253756 # Define function to calculate annualized production prod_fun = function( biomass, Xprime, logPB, taxon, ecofit ){   p = ecofit$internal$parhat   n_taxa = length(ecofit$internal$taxa)   if(!missing(Xprime)) p$Xprime_ij[] = Xprime   if(!missing(logPB)) p$logPB_i[] = logPB   if(missing(taxon)) taxon = ecofit$internal$taxa[n_taxa]   p = add_equilibrium( p,                        scale_solver = ecofit$internal$control$scale_solver,                        noB_i = ifelse(is.na(p$logB_i),1,0),                        type_i = type_i )   p$logF_i = rep(log(0), n_taxa)   p$epsilon_i = rep(0, n_taxa)   data2 = local({                   type_i = type_i                   n_species = n_taxa                   F_type = ecofit$internal$control$F_type                   environment()   })   environment(dBdt) <- data2   State = c( ecofit$rep$out_initial$B_i, rep(0,n_taxa) )   State[match(taxon,ecofit$internal$taxa)] = biomass   #dBdt(Time=0, State=State, Pars=p)   proj = abm3pc_sys(         f = dBdt,         a = 0,          b = 1,         n = ecofit$internal$control$n_steps,         Pars = p,         y0 = State )   biomass1 = rev( proj$y[,match(taxon,ecofit$internal$taxa)] )[1]   return( biomass1 - biomass ) } # Calculate predicted and true curves x = seq(0, 2*K, length=1000)[-1] if(prod_func==\"Scaefer\") y = r * x * (1 - x/K) if(prod_func==\"Fox\") y = r * x * log(K/x) yhat = sapply( x, FUN=prod_fun, ecofit=out,                Xprime = out$internal$parhat$Xprime_ij,                 logPB = out$internal$parhat$logPB_i )  # Solve for Bmsy / B0 in production function dBdt_approx = function(b, x, p){   # dBdt for single autotroph (not annualized)   dBdt_expr = expression(b * p * (1-b) / (x - 1 + b))   # Solve for d/db dBdt = 0 as min_b((d/db dBdt)^2)   #eval( D(dBdt,\"b\") )^2   # OR:  -dBdt   eval(dBdt_expr) } phi1 = optimize( dBdt_approx, lower=0.01, upper=0.99, maximum=TRUE,                 x = 1+exp(out$internal$parhat[['Xprime_ij']]),                  p = exp(out$internal$parhat[['logPB_i']]) )$maximum # Empirical phi2 = x[which.max(yhat)] / 1000  # msy1 = exp(out$internal$parhat$logB_i) * dBdt_approx(phi1,                  x = 1+exp(out$internal$parhat[['Xprime_ij']]),                  p = exp(out$internal$parhat[['logPB_i']]) ) # msy2 = yhat[which.max(yhat)] #  true_msy = y[which.max(y)]  # Plot them plot( x=x, y=y, type=\"l\", xlim=c(0,2*K), ylim=c(0,2*max(y)), lwd=3,        xlab=\"Biomass\", ylab=\"Annual surplus production\" ) lines( x=x, y=yhat, lwd=3, col=\"red\" )    # *exp(out$internal$parhat$logq_i) # Extract estimated biomass Bhat_t = as.list(out$sdrep, what=\"Estimate\", report=TRUE )$B_ti Bse_t = as.list(out$sdrep, what=\"Std. Error\", report=TRUE )$B_ti  # Reformat to long-form data frame for ggplot results = cbind( \"Year\" = years,                  \"True\" = as.vector(B_t),                  \"Obs\" = as.vector(Bobs_t),                  \"Est\" = as.vector(Bhat_t),                  \"SE\" = as.vector(Bse_t) )  # Plot using ggplot library(ggplot2) ggplot(results) +    geom_line( aes(x=as.numeric(Year), y=True), colour=\"red\" ) +    geom_line( aes(x=as.numeric(Year), y=Obs) ) +    geom_line( aes(x=as.numeric(Year), y=Est), linetype=\"dotted\" ) +   geom_ribbon( aes(x=as.numeric(Year), ymin=Est-1.96*SE, ymax=Est+1.96*SE), alpha=0.2)"},{"path":"/articles/surplus_production.html","id":"bivariate-production-model","dir":"Articles","previous_headings":"","what":"Bivariate production model","title":"EcoState as surplus production model","text":"Similarly, fit two-species production model data: can calculate visualize changes production function:","code":"# Inputs taxa = c( \"prey\", \"target\" ) n_taxa = length(taxa) PB_i = c( 5, 0.1 ) QB_i = c( NA, 0.5 ) DC_ij = matrix( c(0,0,1,0), nrow=2 ) X_ij = matrix( 2, nrow=2, ncol=2 ) U_i = c( 0.2, 0.2 ) type = c( \"auto\", \"hetero\" ) EE_i = c( 1, NA )  B_i = c( NA, 1 )  # Settings: specify what parameters to estimate fit_delta = \"target\"   # process errors fit_Q = \"target\"       # catchability coefficient fit_B0 = c()      # non-equilibrium initial condition fit_B = \"target\"       # equilibrium biomass  # Label EwE inputs for each taxon as expected (so users can easily change taxa) names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa   dimnames(DC_ij) = dimnames(X_ij) = list(\"Prey\"=taxa, \"Predator\"=taxa)    # Run model out0 = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_delta,                 fit_B0 = fit_B0,                 control = ecostate_control( nlminb_loops = 0,                                             getsd = FALSE ) )  # Estimate logPB pars = out0$tmb_inputs$p map = out0$tmb_inputs$map #map$Xprime_ij = factor( rep(1,n_taxa) %o% ifelse(type==\"auto\",NA,1) )  # Run model out_bivar = ecostate( taxa = taxa,                 years = years,                 catch = Catch,                 biomass = Biomass,                 PB = PB_i,                 QB = QB_i,                 DC = DC_ij,                 B = B_i,                 EE = EE_i,                 X = X_ij,                 type = type,                 U = U_i,                 fit_B = fit_B,                 fit_Q = fit_Q,                 fit_eps = fit_delta,                 fit_B0 = fit_B0,                 control = ecostate_control( map = map,                                             tmb_par = pars ) ) #> Using `control$tmb_par`, so be cautious in constructing it #> Using `control$map`, so be cautious in constructing it # Calculate annualized production function yhat_bivar = sapply( x, FUN=prod_fun, ecofit=out_bivar, taxon=\"target\",                Xprime = out_bivar$internal$parhat$Xprime_ij,                 logPB = out_bivar$internal$parhat$logPB_i )  # Empirical phi_bivar = x[which.max(yhat_bivar)] / 1000  msy_bivar = yhat_bivar[which.max(yhat_bivar)]   # Plot them plot( x=x, y=y, type=\"l\", xlim=c(0,2*K), ylim=c(0,2*max(y)), lwd=3,        xlab=\"Biomass\", ylab=\"Annual surplus production\" ) matplot( x=x, y=cbind(yhat,yhat_bivar), lwd=3, col=c(\"red\",\"blue\"),           type=\"l\", add=TRUE )   legend( \"topright\", fill=c(\"black\",\"red\",\"blue\"),          legend=c(\"True\",\"1-species\",\"2-species\"), bty=\"n\")"},{"path":"/articles/surplus_production.html","id":"comparison-with-other-models","dir":"Articles","previous_headings":"","what":"Comparison with other models","title":"EcoState as surplus production model","text":"can compare state-space production model continuous time (SPiCT):  Similarly, can compare Just Another Bayesian Biomass Assessment (JABBA):  Comparing two shows SPICT EcoState errors estimating population scale, presumably due mis-specifying production function:","code":"library(spict) #> Loading required package: TMB #> Welcome to spict_v1.3.8@107a32  # Format for SPiCT datalist = list(   obsC = C_t[-1],   timeC = years[-1],   obsI = Bobs_t,   timeI = years               )  # Fit and plot res <- fit.spict(datalist) plotspict.biomass(res) library(JABBA)  # Compile JABBA JAGS model and input object jbinput = build_jabba( catch = data.frame(Year=years, Total=C_t)[-1,],                        cpue = data.frame(Year=years, Index=Bobs_t)[-1,],                        se = data.frame(Year=years, Index=0.1)[-1,],                        assessment = \"target\",                        scenario = \"TestRun\",                        model.type = \"Schaefer\",                        sigma.est = FALSE,                        fixed.obsE = 0.1 ) #>  #> ><> Prepare JABBA input data <>< #>  #> ><> Assume Catch with error CV = 0.1 <>< #>  #> ><> Model type:Schaefer <>< #>  #> ><> Shape m =2 #>  #> ><> K prior mean =888.164844109276and CV =1(log.sd = 0.832554611157698) #>  #> ><> r prior mean =0.2and CV =0.532940350027788(log.sd = 0.5) #>  #> ><> Psi (B1/K) prior mean =0.9and CV =0.25withlnormdestribution #>  #>  #>  #> ><> ALWAYS ENSURE to adjust default settings to your specific stock <><  # Fit JABBA (here mostly default value - careful) bet1 = fit_jabba(jbinput, quickmcmc=TRUE) #> module glm loaded #> Compiling model graph #>    Resolving undeclared variables #>    Allocating nodes #> Graph information: #>    Observed stochastic nodes: 120 #>    Unobserved stochastic nodes: 124 #>    Total graph size: 2169 #>  #> Initializing model #>  #> ><> Produce results output of Schaefer model for target TestRun <>< #>  #>  #> ><> Scenario TestRun_Schaefer completed in 0 min and 28 sec <><  # Make individual plots jbplot_cpuefits(bet1) #>  #> ><> jbplot_cpue() - fits to CPUE <>< # Compare estimates knitr::kable(rbind(   \"True\" = c(\"q\" = q, \"K\"=K, \"MSY\"=true_msy),   \"EcoState 1-species\" = c(exp(out$opt$par[c('logq_i','logB_i')]),msy2),   \"EcoState 2-species\" = c(exp(out_bivar$opt$par[c('logq_i','logB_i')]),msy_bivar),   \"SPiCT\" = c(res$value[c('q','K','MSY')]),   \"JABBA\" = c(bet1$pars[c('q','K'),'Median'],bet1$estimates['MSY','mu']) ), digits=3)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James T. Thorson. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thorson, J.  Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G., McHuron, E.., Nielsen, J.N., Townsend, H., Whitehouse, G.. EcoState:  Extending Ecopath Ecosim estimate biological parameters process errors using RTMB time-series data","code":"@Article{,   title = {EcoState:  Extending Ecopath with Ecosim to estimate biological parameters and process errors using RTMB and time-series data},   journal = {In review},   year = {2024},   author = {J. T. Thorson and K. Kristensen and K. Aydin and S. Gaichas and D. G. Kimmel and E. A. McHuron and J. N. Nielsen and H. Townsend and G. A. Whitehouse}, }"},{"path":"/index.html","id":"ecostate","dir":"","previous_headings":"","what":"State-Space Extension of EcoPath with EcoSim","title":"State-Space Extension of EcoPath with EcoSim","text":"Package EcoState fits state-space mass-balance model intended aquatic ecosystems, using mass-balance equations matching dynamical equations matching Ecosim. Unlike Ecopath Ecosim (EwE), fits biological parameters (e.g., equilibrium biomass predator-prey vulnerability) measurement parameters (e.g., catchability coefficients) via fit time-series data. also estimates additional process errors representing nonstationarity growth efficiency, ecotrophic efficient, migration, unmodeled processes.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"State-Space Extension of EcoPath with EcoSim","text":"EcoState can installed GitHub using:","code":"library(remotes) install_github( \"James-Thorson-NOAA/EcoState\" )"},{"path":"/reference/abm3pc_sys.html","id":null,"dir":"Reference","previous_headings":"","what":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"Third-order Adams-Bashford-Moulton predictor-corrector method.","code":""},{"path":"/reference/abm3pc_sys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"","code":"abm3pc_sys(f, a, b, y0, n, Pars)"},{"path":"/reference/abm3pc_sys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time Pars named list parameters passed f","code":""},{"path":"/reference/abm3pc_sys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adams-Bashford-Moulton for system of equations — abm3pc_sys","text":"Combined Adams-Bashford Adams-Moulton (: multi-step) method third order corrections according predictor-corrector approach. Copied pracma GPL-3, small modifications work RTMB","code":""},{"path":"/reference/add_equilibrium.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute equilibrium values — add_equilibrium","title":"Compute equilibrium values — add_equilibrium","text":"Compute equilibrium values","code":""},{"path":"/reference/add_equilibrium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute equilibrium values — add_equilibrium","text":"","code":"add_equilibrium(ecoparams, scale_solver, noB_i, type_i)"},{"path":"/reference/add_equilibrium.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute equilibrium values — add_equilibrium","text":"ecoparams list parameters","code":""},{"path":"/reference/add_equilibrium.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute equilibrium values — add_equilibrium","text":"todo","code":""},{"path":"/reference/compute_nll.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute negative log-likelihood for EcoState model — compute_nll","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"Compute negative log-likelihood EcoState model","code":""},{"path":"/reference/compute_nll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"","code":"compute_nll(p)"},{"path":"/reference/compute_nll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"p list parameters","code":""},{"path":"/reference/compute_nll.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute negative log-likelihood for EcoState model — compute_nll","text":"todo","code":""},{"path":"/reference/compute_tracer.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate tracers, e.g., trophic level — compute_tracer","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"Calculate tracer propagates consumption.","code":""},{"path":"/reference/compute_tracer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"","code":"compute_tracer(   Q_ij,   inverse_method = c(\"Penrose_moore\", \"Standard\"),   type_i,   tracer_i = rep(1, nrow(Q_ij)) )"},{"path":"/reference/compute_tracer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"Q_ij Consumption prey predator j units biomass. inverse_method whether use pseudoinverse standard inverse tracer_i indicator matrix specifying traver value","code":""},{"path":"/reference/compute_tracer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate tracers, e.g., trophic level — compute_tracer","text":"Trophic level \\(y_i\\) predator \\(\\) defined : $$ \\mathbf{y = l Q^* + 1} $$ \\(\\mathbf{Q*}\\) proportion consumption predator (column) different prey (rows).  identify primary producers taxa consumption (column 0s), assign first trophic level. generically, tracer might used track movement biomass consumption.  example, tracer \\(x_i\\) 1 base pelagic food chain, 0 otherwise, can calculate proportion pelagic vs. nonpelagic biomass taxon: $$ \\mathbf{y = l Q^* + x} $$ allows us separate alternative components foodweb.","code":""},{"path":"/reference/dBdt.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamics from EcoSim — dBdt","title":"Dynamics from EcoSim — dBdt","text":"Compute system differential equations representing EcoSim dynamics","code":""},{"path":"/reference/dBdt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamics from EcoSim — dBdt","text":"","code":"dBdt(Time, State, Pars, what = \"dBdt\")"},{"path":"/reference/dBdt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamics from EcoSim — dBdt","text":"Time todo State todo Pars todo todo","code":""},{"path":"/reference/dBdt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamics from EcoSim — dBdt","text":"object (list) ranges. Elements include: G_i Biomass growth per time g_i Biomass growth per time per biomass M2_i Consumptive mortality per time m2_i Consumptive mortality per time per biomass M_i Natural mortality per time m_i Natural mortality per time per biomass (.e., m2_i + m0_i) Q_ij Consumption per time prey (rows) predator (columns)","code":""},{"path":"/reference/dBdt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dynamics from EcoSim — dBdt","text":"todo","code":""},{"path":"/reference/eastern_bering_sea.html","id":null,"dir":"Reference","previous_headings":"","what":"eastern Bering Sea ecosystem data — eastern_bering_sea","title":"eastern Bering Sea ecosystem data — eastern_bering_sea","text":"Data used demonstrate Model Intermediate Complexity (MICE) eastern Bering Sea. data(eastern_bering_sea) loads list includes four components: Survey long-form data-frame three columns, providing Year, Mass (relative units taxa, million metric tons Pollock, Cod, Arrowtooth, NFS), Taxon year available data Catch long-form data-frame three columns, providing Year, Mass (million metric tons), Taxon year available data P_over_B numeric vector unitless ratio biomass production population biomass taxon Q_over_B numeric vector unitless ratio biomass consumption population biomass taxon Diet_proportions numeric matrix column lists proportion biomass consumed provided prey (row)","code":""},{"path":"/reference/eastern_bering_sea.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"eastern Bering Sea ecosystem data — eastern_bering_sea","text":"","code":"data(eastern_bering_sea)"},{"path":"/reference/eastern_bering_sea.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"eastern Bering Sea ecosystem data — eastern_bering_sea","text":"data compiled come variety sources: Northern fur seal (NFS) survey absolute index, corrected proportion time spent eastern Bering Sea.  NFS QB developed bioenergetic model also corrected seasonal residency. provided Elizabeth McHuron. post-processed variety ways, treated index abundance NFS uses. Pollock, cod, arrowtooth surveys bottom trawl survey, cod arrowtooth treated absolute index. Copepod zooplankton oblique tow bongo net survey, data provided Dave Kimmel.  post-processed account spatially seaonally imbalanced data. P_over_B, Q_over_B Diet_proportions values derived Rpath models, provided Andy Whitehouse. Primary producers annual index relative biomass, developed monthly satellite measurements provided Jens Nielsen. See Thorson et al. (review) details regarding data standardization sources","code":""},{"path":"/reference/ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"fit EcoState model — ecostate","title":"fit EcoState model — ecostate","text":"Estimate parameters EcoState model","code":""},{"path":"/reference/ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fit EcoState model — ecostate","text":"","code":"ecostate(   taxa,   years,   catch,   biomass,   PB,   QB,   B,   DC,   EE,   X,   type,   U,   fit_B = vector(),   fit_Q = vector(),   fit_B0 = vector(),   fit_EE = vector(),   fit_eps = vector(),   control = ecostate_control() )"},{"path":"/reference/ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fit EcoState model — ecostate","text":"taxa Character vector taxa included model. years Integer-vector years included model catch long-form data frame columns Mass, Year  Taxon biomass long-form data frame columns Mass, Year  Taxon, Mass assumed units catch PB numeric-vector names matching taxa, providing ratio production biomass taxon QB numeric-vector names matching taxa, providing ratio consumption biomass taxon B numeric-vector names matching taxa, providing starting (fixed) value equilibrium biomass taxon DC numeric-matrix rownames colnames matching taxa, column provides diet proportion given predator X numeric-matrix rownames colnames matching taxa, element gives vulnerability parameter given interaction. type character-vector names matching taxa elements c(\"auto\",\"hetero\",\"detritus\"), indicating whether taxon primary producer, consumer/predator, detritus, respectively. U numeric-vector names matching taxa, providing proportion consumption unassimilated therefore exported detritus fit_B Character-vector listing taxa equilibrium biomass estimated fixed effect fit_Q Character-vector listing taxa catchability coefficient estimated fixed effect fit_B0 Character-vector listing taxa ratio initial equilibrium biomass estimated fixed effect fit_eps Character-vector listing taxa model estimate annual process errors dB/dt control Output ecostate_control(), used define user settings.","code":""},{"path":"/reference/ecostate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"fit EcoState model — ecostate","text":"taxa must included QB, PB, B, DC, additional taxa can QB, PB, B, DC taxa.  taxa can used redefine set modeled species without changing inputs","code":""},{"path":"/reference/ecostate_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Detailed control for ecostate structure — ecostate_control","title":"Detailed control for ecostate structure — ecostate_control","text":"Define list control parameters.","code":""},{"path":"/reference/ecostate_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detailed control for ecostate structure — ecostate_control","text":"","code":"ecostate_control(   nlminb_loops = 1,   newton_loops = 0,   eval.max = 1000,   iter.max = 1000,   getsd = TRUE,   silent = getOption(\"ecostate.silent\", TRUE),   trace = getOption(\"ecostate.trace\", 0),   verbose = getOption(\"ecostate.verbose\", FALSE),   profile = c(\"logF_ti\"),   random = c(\"epsilon_ti\", \"alpha_ti\"),   tmb_par = NULL,   map = NULL,   getJointPrecision = FALSE,   integration_method = c(\"ABM\", \"RK4\", \"ode23\", \"rk4\", \"lsoda\"),   process_error = c(\"epsilon\", \"alpha\"),   n_steps = 10,   F_type = c(\"integrated\", \"averaged\"),   scale_solver = c(\"joint\", \"simple\"),   inverse_method = c(\"Standard\", \"Penrose_moore\"),   tmbad.sparse_hessian_compress = 1,   start_tau = 0.001 )"},{"path":"/reference/ecostate_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detailed control for ecostate structure — ecostate_control","text":"nlminb_loops Integer number times call stats::nlminb(). newton_loops Integer number Newton steps running stats::nlminb(). eval.max Maximum number evaluations objective function allowed. Passed control stats::nlminb(). iter.max Maximum number iterations allowed. Passed control stats::nlminb(). getsd Boolean indicating whether call TMB::sdreport() silent Disable terminal output inner optimizer? trace Parameter values printed every trace iteration outer optimizer. Passed control stats::nlminb(). verbose Output additional messages model steps fitting? tmb_par list parameters starting values, shape identical tinyVAST(...)$internal$parlist map list mapping values, passed RTMB::MakeADFun getJointPrecision whether get joint precision matrix.  Passed sdreport. integration_method numerical integration method use. \"ABM\" uses native-R versions Adam-Bashford, code\"RK4\" uses native-R version Runge-Kutta-4, code\"ode23\" uses native-R version adaptive Runge-Kutta-23, adapted pracma functions. \"rk4\" lsoda use methods deSolve::ode implemented RTMBode::ode process_error Whether include process error continuous rate (.e., \"innovation\" parameterization, process_error=\"epsilon\") discrete difference expected predicted biomass (.e., \"state-space\" parameterization), process_error=\"alpha\"former interpretable, whereas latter much computationally efficient. F_type whether integrate catches along biomass (\"integrated\") calculate catches Baranov catch equation applied average biomass (\"averaged\") tmbad.sparse_hessian_compress passed TMB::config(), enabling experimental feature save memory first computing inner Hessian matrix.  Using tmbad.sparse_hessian_compress=1 seems effect MLE (although users probably confirm ), hugely reduces memory use small large models. Using tmbad.sparse_hessian_compress=1 seems hugely speed model-fitting large model results small decrease speed model-fitting small model. start_tau Starting value standard deviation process errors","code":""},{"path":"/reference/ginv.html","id":null,"dir":"Reference","previous_headings":"","what":"Penrose-Moore pseudoinverse — ginv","title":"Penrose-Moore pseudoinverse — ginv","text":"Extend MASS:ginv work RTMB","code":""},{"path":"/reference/ginv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penrose-Moore pseudoinverse — ginv","text":"","code":"ginv(x)"},{"path":"/reference/ginv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penrose-Moore pseudoinverse — ginv","text":"X Matrix used compute pseudoinverse","code":""},{"path":"/reference/myode.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic ODE solver — myode","title":"Generic ODE solver — myode","text":"Interface RTMBode::ode, interface deSolve::ode","code":""},{"path":"/reference/myode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic ODE solver — myode","text":"","code":"myode(f, a, b, y0, n, Pars, method = \"lsode\")"},{"path":"/reference/myode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic ODE solver — myode","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time Pars named list parameters passed f steps number steps b.","code":""},{"path":"/reference/myode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic ODE solver — myode","text":"Todo","code":""},{"path":"/reference/ode23.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-stiff (and stiff) ODE solvers — ode23","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"Runge-Kutta (2, 3)-method variable step size, resp","code":""},{"path":"/reference/ode23.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"","code":"ode23(f, a, b, y0, n, Pars, rtol = 0.001, atol = 1e-06)"},{"path":"/reference/ode23.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time n used Pars named list parameters passed f rtol relative tolerance. atol absolute tolerance.","code":""},{"path":"/reference/ode23.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Non-stiff (and stiff) ODE solvers — ode23","text":"Copied pracma GPL-3, small modifications work RTMB","code":""},{"path":"/reference/plot_foodweb.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot foodweb — plot_foodweb","title":"Plot foodweb — plot_foodweb","text":"Plot consumption directed graph including taxa (vertices) biomass consumed (arrows).  Taxa located using tracers, default y-axis trophic level.  #'","code":""},{"path":"/reference/plot_foodweb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot foodweb — plot_foodweb","text":"","code":"plot_foodweb(   Q_ij,   type_i,   xtracer_i,   ytracer_i = rep(1, nrow(Q_ij)),   B_i = rep(1, nrow(Q_ij)),   taxa_labels = letters[1:nrow(Q_ij)],   xloc,   yloc )"},{"path":"/reference/plot_foodweb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot foodweb — plot_foodweb","text":"Q_ij Consumption prey predator j units biomass. inverse_method whether use pseudoinverse standard inverse","code":""},{"path":"/reference/plot_foodweb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot foodweb — plot_foodweb","text":"Trophic level \\(l_i\\) predator \\(\\) defined : $$ \\mathbf{l - 1 = l Q^*} $$ \\(\\mathbf{Q*}\\) proportion consumption predator (column) different prey (rows).  identify primary producers taxa consumption (column 0s), assign first trophic level.","code":""},{"path":"/reference/print.ecostate.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitted ecostate object — print.ecostate","title":"Print fitted ecostate object — print.ecostate","text":"Prints output fitted ecostate model","code":""},{"path":"/reference/print.ecostate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitted ecostate object — print.ecostate","text":"","code":"# S3 method for class 'ecostate' print(x, ...)"},{"path":"/reference/print.ecostate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitted ecostate object — print.ecostate","text":"x Output ecostate ... used","code":""},{"path":"/reference/print.ecostate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print fitted ecostate object — print.ecostate","text":"return value, called provide clean terminal output calling fitted object terminal.","code":""},{"path":"/reference/print_ecopars.html","id":null,"dir":"Reference","previous_headings":"","what":"Print EcoSim parameters — print_ecopars","title":"Print EcoSim parameters — print_ecopars","text":"Prints parameters defining EcoSim dynamics","code":""},{"path":"/reference/print_ecopars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print EcoSim parameters — print_ecopars","text":"","code":"print_ecopars(x, silent = FALSE)"},{"path":"/reference/print_ecopars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print EcoSim parameters — print_ecopars","text":"x Output ecostate silent whether print terminal","code":""},{"path":"/reference/print_ecopars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print EcoSim parameters — print_ecopars","text":"invisibly returns table printed","code":""},{"path":"/reference/rk4sys.html","id":null,"dir":"Reference","previous_headings":"","what":"Classical Runge-Kutta for system of equations — rk4sys","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"Classical Runge-Kutta order 4.","code":""},{"path":"/reference/rk4sys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"","code":"rk4sys(f, a, b, y0, n, Pars)"},{"path":"/reference/rk4sys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"f function differential equation \\(y' = f(x, y)\\); defined function \\(R \\times R^m \\rightarrow R^m\\), \\(m\\) number equations. starting time interval integrate b ending time interval integrate. y0 starting values time Pars named list parameters passed f steps number steps b.","code":""},{"path":"/reference/rk4sys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classical Runge-Kutta for system of equations — rk4sys","text":"Classical Runge-Kutta order 4 (systems ) ordinary differential equations fixed step size. Copied pracma GPL-3, small modifications work RTMB","code":""},{"path":"/news/index.html","id":"ecostate-010","dir":"Changelog","previous_headings":"","what":"EcoState 0.1.0","title":"EcoState 0.1.0","text":"Initial public release","code":""}]
