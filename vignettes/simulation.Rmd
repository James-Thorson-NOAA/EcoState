---
title: "Demonstrating EcoState via simulation"
author: "James Thorson"
output: rmarkdown::html_vignette
#output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Demonstrating EcoState via simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
# Install locally
#  devtools::install_local( R'(C:\Users\James.Thorson\Desktop\Git\ecostate)', force=TRUE )
# Build
#  setwd(R'(C:\Users\James.Thorson\Desktop\Git\ecostate)'); devtools::build_rmd("vignettes/simulation.Rmd"); rmarkdown::render( "vignettes/simulation.Rmd", rmarkdown::pdf_document())
```

```{r setup, echo=TRUE, message=FALSE}
library(EcoState)
```

`ecostate` is an R package for fitting the mass-balance dynamics specified by EcoSim as a state-space model.   We here highlight a few features in particular.

## Simulation demonstration

We first simulate new data.  To do so, we specify a 5-species ecosystem:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Time-interval
years = 1981:2020
n_years = length(years)

# Name taxa (optional, for illustration)
taxa = c("Producer_1", "Producer_2", "Consumer_1", "Consumer_2", "Predator_1", "Predator_2")
n_taxa = length(taxa)

# Ecopath-with-EcoSim parameters
# Diet matrix
DC_ij = matrix( c(
  0,    0,      0.8,   0.2,   0,    0,
  0,    0,      0.2,   0.8,   0,    0,
  0,    0,      0,     0,     0.6,  0.4,
  0,    0,      0,     0,     0.4,  0.6,
  0,    0,      0,     0,     0,    0,
  0,    0,      0,     0,     0,    0
), byrow=TRUE, ncol=n_taxa)
which_primary = which(colSums(DC_ij)==0)
PB_i = c( 90, 90, 4, 2, 0.2, 0.1 )         # Reciprocal of mean age according to Polovina-1984 ~= M
QB_i = c( NA, NA, 10, 15, 3, 4 )
#EE_i = rep(NA, n_taxa)
EE_i = c( 0.9, 0.9, 0.9, 0.9, NA, NA )
B0_i = c( NA, NA, NA, NA, 1, 1 )
V_ij = matrix( 2, nrow=n_taxa, ncol=n_taxa )
V_ij[,which_primary] = 91

# Simulation parameters
fished_i = c( FALSE, FALSE, FALSE, FALSE, TRUE, TRUE )
sigmaB_i = c(0.1, 0.1, 0.02, 0.02, 0.1, 0.1) # Taxa 3-4 crashes solver if sigmaB > 0.02
```

We then loop through years while projecting dynamics, given that the two consumers are subject to increased fishing over time:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Simulate process errors
set.seed(101)
rarray = \(x,dims=dim(x),sd) array( sd*rnorm(prod(dims)), dim=dims )
epsilon_ti = rarray(dims=c(n_years,n_taxa),sd=1) * outer(rep(1,n_years),sigmaB_i)

# Choose method to integrate instantaneous rates for annual dynamics
n_steps = 10
project_vars = abm3pc_sys

# Define parameters
pars = list( logB_i = log(B0_i),
             logPB_i = log(PB_i),
             logQB_i = log(QB_i),
             Vprime_ij = log(V_ij -1),
             EE_i = EE_i,
             DC_ij = DC_ij,
             noB_i = ifelse(is.na(B0_i),1,0),
             epsilon_i = deltaB_ti[t,],
             logF_i = log(F_t),
             which_primary = which(colSums(DC_ij)==0),
             F_type = "integrated",
             n_species = n_taxa )

# Solve for equilibrium values
pars_full = add_equilibrium( pars,
                             scale_solver = "joint",
                             noB_i = ifelse(is.na(pars$logB_i),1,0) )

# Project forward
Bobs_ti = Cobs_ti = B_ti = C_ti = array(NA, dim=c(n_years,n_taxa), dimnames=list("Year"=years,"Taxon"=taxa) )
B_ti[1,] = exp(pars_full$logB_i)
C_ti[1,] = NA

for( t in seq_along(years)[-1] ){
  # Fishing mortality ramps up for two predators
  F_t = c( 0, 0, t/n_years*0.2, 0, t/n_years*0.1 )

  #
  pars_t = pars_full
  pars_t$logF_i = log(F_t)
  pars_t$epsilon_i = epsilon_ti[t,]
  
  # Integrate dynamics annually
  sim = project_vars(
        f = dBdt,
        a = years[t-1], 
        b = years[t],
        n = n_steps,
        Pars = pars_full,
        y0 = c( B_ti[t-1,], rep(0,n_taxa) ) )
  
  # Record results
  B_ti[t,] = sim$y[nrow(sim$y),seq_len(n_taxa)]
  C_ti[t,] = sim$y[nrow(sim$y),n_taxa+seq_len(n_taxa)]

  # Simulate measurement errors
  Bobs_ti[t,] = B_ti[t,] * exp(0.1*rnorm(n_taxa))
  Cobs_ti[t,] = ifelse(C_ti[t,]==0,NA,C_ti[t,]) * exp(0.1*rnorm(n_taxa))
}
```

Next, we reformat simulated biomass and catch time-series into long-form data frames and fit them with `ecostate`

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
# reformat to longform data-frame
Catch = na.omit(data.frame(expand.grid(dimnames(Cobs_ti)), "Mass"=as.vector(Cobs_ti)))
Biomass = na.omit(data.frame(expand.grid(dimnames(Bobs_ti)), "Mass"=as.vector(Bobs_ti)))

# Settings: specify what parameters to estimate
fit_delta = taxa   # process errors
fit_Q = taxa       # catchability coefficient
fit_B0 = taxa      # non-equilibrium initial condition
fit_B = c()       # equilibrium biomass

# Solving for EE and giving uninformed initial values for biomass
fittedB_i = rep(1,n_taxa)
fittedEE_i = rep(NA, n_taxa)

# Label EwE inputs for each taxon as expected (so users can easily change taxa)
names(PB_i) = names(QB_i) = names(fittedB_i) = names(fittedEE_i) = taxa
  dimnames(DC_ij) = dimnames(V_ij) = list("Prey"=taxa, "Predator"=taxa)
  
# Run model
out = ecostate( taxa = taxa,
                years = years,
                catch = Catch,
                biomass = Biomass,
                PB = PB_i,
                QB = QB_i,
                DC = DC_ij,
                B = fittedB_i,
                EE = fittedEE_i,
                V = V_ij,
                fit_B = fit_B,
                fit_Q = fit_Q,
                fit_eps = fit_delta,
                fit_B0 = fit_B0,
                control = ecostate_control( inverse_method = "Standard", 
                                            trace = 1,
                                            nlminb_loops = 1,
                                            getsd = TRUE ) )
```

Finally, we can extract elements from the fitted model, and plot them easily using ggplot2 to compare them with known (simulated) values:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Extract estimated biomass
Bhat_ti = as.list(out$sdrep, what="Estimate", report=TRUE )$Bhat_ti
Bse_ti = as.list(out$sdrep, what="Std. Error", report=TRUE )$Bhat_ti

# Reformat to long-form data frame for ggplot
results = expand.grid(dimnames(Bobs_ti))
results = cbind( results, 
                 "True" = as.vector(B_ti),
                 "Est" = as.vector(Bhat_ti),
                 "SE" = as.vector(Bse_ti) )

# Plot using ggplot
library(ggplot2)
ggplot(results) + 
  geom_line( aes(x=as.numeric(Year), y=True) ) + 
  facet_wrap( vars(Taxon), scale="free" ) +
  geom_line( aes(x=as.numeric(Year), y=Est), linetype="dotted" ) +
  geom_ribbon( aes(x=as.numeric(Year), ymin=Est-SE, ymax=Est+SE), alpha=0.2)                
```

We can also explore estimating additional parameters.  Here, we explore estimating vulnerability:

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
# Run model
out0 = ecostate( taxa = taxa,
                years = years,
                catch = Catch,
                biomass = Biomass,
                PB = PB_i,
                QB = QB_i,
                DC = DC_ij,
                B = B0_i,
                EE = EE_i,
                fit_B = fit_B,
                fit_Q = fit_Q,
                fit_eps = fit_delta,
                fit_B0 = fit_B0,
                control = ecostate_control( inverse_method = "Standard", # Avoids using Penrose-Moore inverse, which isn't working in RTMB
                                            nlminb_loops = 0,
                                            getsd = FALSE ) )

# Change tmb_par
tmb_par = out0$tmb_inputs$p
  tmb_par$logV_ij[] = log(1.5)
map = out0$tmb_inputs$map
  map$logV_ij = factor( array(1,dim=dim(tmb_par$logV_ij)) )

# Run model
out1 = ecostate( taxa = taxa,
                years = years,
                catch = Catch,
                biomass = Biomass,
                PB = PB_i,
                QB = QB_i,
                DC = DC_ij,
                B = B0_i,
                EE = EE_i,
                fit_B = fit_B,
                fit_Q = fit_Q,
                fit_eps = fit_delta,
                fit_B0 = fit_B0,
                control = ecostate_control( inverse_method = "Standard", # Avoids using Penrose-Moore inverse, which isn't working in RTMB
                                            nlminb_loops = 1,
                                            getsd = FALSE,
                                            tmb_par = tmb_par,
                                            map = map ) )
```