---
title: "EcoState as surplus production model"
author: "James Thorson"
output: rmarkdown::html_vignette
#output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{EcoState as surplus production model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
# Install locally
#  devtools::install_local( R'(C:\Users\James.Thorson\Desktop\Git\ecostate)', force=TRUE )
#  devtools::install_github( 'James-Thorson-NOAA/ecostate', force=TRUE )
# Build
#  setwd(R'(C:\Users\James.Thorson\Desktop\Git\ecostate)'); devtools::build_rmd("vignettes/surplus_production.Rmd"); rmarkdown::render( "vignettes/surplus_production.Rmd", rmarkdown::pdf_document())
```

```{r setup, echo=TRUE, message=FALSE}
library(EcoState)
set.seed(101)
```

`ecostate` is an R package for fitting the mass-balance dynamics specified by EcoSim as a state-space model.   It can be used as a surplus production model by treating a single species as a "producer"

## Simulation demonstration

We first simulate new data.  To do so, we simulate a Schaefer production model with Gompertz effort dynamics:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Time-interval
years = 1981:2020
n_years = length(years)

# Biology
r = 0.2
#MSY = 100
K = 1000
sigmaB = 0.5
B0 = K * exp(sigmaB*rnorm(1))
prod_func = c("Schaefer", "Fox")[2]

# Effort dynamics
Bequil = 0.4 * K
Brate = 0.2
sigmaE = 0.1
E0 = 0.01

# Survey
q = 1
sigmaQ = 0.1

#
Pbar_t = P_t = C_t = E_t = B_t = rep(NA, n_years)
B_t[1] = B0
E_t[1] = E0

#
for( t in 2:n_years ){
  if(prod_func=="Scaefer") Pbar_t[t] = B_t[t-1] + r * B_t[t-1] * (1 - B_t[t-1]/K)
  if(prod_func=="Fox") Pbar_t[t] = r * B_t[t-1] * log(K / B_t[t-1])
  P_t[t] = Pbar_t[t] * exp(sigmaB*rnorm(1))
  B_t[t] = B_t[t-1] + P_t[t]
  E_t[t] = E_t[t-1] * (B_t[t-1]/Bequil)^Brate * exp(sigmaE*rnorm(1))
  C_t[t] = B_t[t] * (1 - exp(-E_t[t]))
  B_t[t] = B_t[t] - C_t[t]
}
Bobs_t = q * B_t * exp(sigmaQ * rnorm(n_years))

# 
matplot( x=years, y=cbind(B_t,Bobs_t,C_t), type="l", log="y", lty="solid")
```

We then set up inputs to EcoState

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Name taxa (optional, for illustration)
taxa = "target"
n_taxa = length(taxa)

# Ecopath-with-EcoSim parameters
# Diet matrix
DC_ij = array( 0, dim=c(1,1) )
PB_i = 0.1
QB_i = NA
EE_i = 1
B_i = 1
U_i = 0.2
type_i = "auto"
V_ij = array( 2, dim=c(1,1) )

# reformat to longform data-frame
Catch = na.omit(data.frame( "Mass" = C_t, "Year" = years, "Taxon" = taxa ))
Biomass = data.frame( "Mass" = Bobs_t, "Year" = years, "Taxon" = taxa )
```

Next, we fit them with `ecostate`

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
# Settings: specify what parameters to estimate
fit_delta = taxa   # process errors
fit_Q = taxa       # catchability coefficient
fit_B0 = c()      # non-equilibrium initial condition
fit_B = taxa       # equilibrium biomass

# Treat it as an autotroph (given there's no prey to consume)
type = "auto"

# Label EwE inputs for each taxon as expected (so users can easily change taxa)
names(PB_i) = names(QB_i) = names(B_i) = names(EE_i) = names(type) = names(U_i) = taxa
  dimnames(DC_ij) = dimnames(V_ij) = list("Prey"=taxa, "Predator"=taxa)
  
# Run model
out0 = ecostate( taxa = taxa,
                years = years,
                catch = Catch,
                biomass = Biomass,
                PB = PB_i,
                QB = QB_i,
                DC = DC_ij,
                B = B_i,
                EE = EE_i,
                V = V_ij,
                type = type,
                U = U_i,
                fit_B = fit_B,
                fit_Q = fit_Q,
                fit_eps = fit_delta,
                fit_B0 = fit_B0,
                control = ecostate_control( nlminb_loops = 0,
                                            getsd = FALSE ) )

# Estimate logPB
pars = out0$tmb_inputs$p
map = out0$tmb_inputs$map
map$Vprime_ij = factor(1)

# Run model
out = ecostate( taxa = taxa,
                years = years,
                catch = Catch,
                biomass = Biomass,
                PB = PB_i,
                QB = QB_i,
                DC = DC_ij,
                B = B_i,
                EE = EE_i,
                V = V_ij,
                type = type,
                U = U_i,
                fit_B = fit_B,
                fit_Q = fit_Q,
                fit_eps = fit_delta,
                fit_B0 = fit_B0,
                control = ecostate_control( map = map,
                                            tmb_par = pars ) )

# print output to terminal
out
```

Finally we can compare the estimated and true production function

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
# Define function to calculate annualized production
prod_fun = function( biomass, Vprime, logPB ){
  p = out$internal$parhat
  if(!missing(Vprime)) p$Vprime_ij[] = Vprime
  if(!missing(logPB)) p$logPB_i[] = logPB
  p = add_equilibrium( p,
                       scale_solver = out$internal$control$scale_solver,
                       noB_i = ifelse(is.na(p$logB_i),1,0),
                       type_i = type_i )
  p$logF_i = rep(log(0), n_taxa)
  p$epsilon_i = rep(0, n_taxa)
  data2 = local({
                  type_i = type_i
                  n_species = n_taxa
                  F_type = out$internal$control$F_type
                  environment()
  })
  environment(dBdt) <- data2
  proj = abm3pc_sys(
        f = dBdt,
        a = 0, 
        b = 1,
        n = out$internal$control$n_steps,
        Pars = p,
        y0 = c(biomass, 0) )
  return( rev(proj$y[,1])[1] - biomass )
}

# Calculate predicted and true curves
x = seq(0, 2*K, length=1000)[-1]
if(prod_func=="Scaefer") y = r * x * (1 - x/K)
if(prod_func=="Fox") y = r * x * log(K/x)
yhat = sapply( x, FUN=prod_fun, 
               Vprime = out$internal$parhat$Vprime_ij, 
               logPB = out$internal$parhat$logPB_i )

# Plot them
plot( x=x, y=y, type="l", xlim=c(0,2*K), ylim=c(0,2*max(y)), lwd=3 )
lines( x=x, y=yhat, lwd=3, col="red" )    # *exp(out$internal$parhat$logq_i)
```

And we can also plot the estimated and true biomass

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
# Extract estimated biomass
Bhat_t = as.list(out$sdrep, what="Estimate", report=TRUE )$B_ti
Bse_t = as.list(out$sdrep, what="Std. Error", report=TRUE )$B_ti

# Reformat to long-form data frame for ggplot
results = cbind( "Year" = years,
                 "True" = as.vector(B_t),
                 "Obs" = as.vector(Bobs_t),
                 "Est" = as.vector(Bhat_t),
                 "SE" = as.vector(Bse_t) )

# Plot using ggplot
library(ggplot2)
ggplot(results) + 
  geom_line( aes(x=as.numeric(Year), y=True), colour="red" ) + 
  geom_line( aes(x=as.numeric(Year), y=Obs) ) + 
  geom_line( aes(x=as.numeric(Year), y=Est), linetype="dotted" ) +
  geom_ribbon( aes(x=as.numeric(Year), ymin=Est-1.96*SE, ymax=Est+1.96*SE), alpha=0.2)                
```

## Comparison with other models

We can compare this with a state-space production model in continuous time (SPiCT):

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
library(spict)

# Format for SPiCT
datalist = list(
  obsC = C_t[-1],
  timeC = years[-1],
  obsI = Bobs_t,
  timeI = years              
)

# Fit and plot
res <- fit.spict(datalist)
plotspict.biomass(res)
```

Similarly, we can compare it with Just Another Bayesian Biomass Assessment (JABBA):

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
library(JABBA)

# Compile JABBA JAGS model and input object
jbinput = build_jabba( catch = data.frame(Year=years, Total=C_t)[-1,],
                       cpue = data.frame(Year=years, Index=Bobs_t)[-1,],
                       se = data.frame(Year=years, Index=0.1)[-1,],
                       assessment = "target",
                       scenario = "TestRun",
                       model.type = "Schaefer",
                       sigma.est = FALSE,
                       fixed.obsE = 0.1 )

# Fit JABBA (here mostly default value - careful)
bet1 = fit_jabba(jbinput, quickmcmc=TRUE)

# Make individual plots
jbplot_cpuefits(bet1)
```

Comparing the two shows that SPICT and EcoState both have errors in estimating population scale, presumably due to mis-specifying the production function: 

```{r, echo=TRUE, message=TRUE, fig.width=7, fig.height=7}
# Compare estimates
knitr::kable(rbind(
  "True" = c("q" = q, "K"=K),
  "EcoState" = exp(out$opt$par[c('logq_i','logB_i')]),
  "SPiCT" = res$value[c('q','K')],
  "JABBA" = bet1$pars[c('q','K'),'Median']
), digits=3)
```